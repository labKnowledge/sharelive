<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DropShare - Professional P2P Transfer</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0f172a;
            --surface: #1e293b;
            --border: #334155;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --success: #10b981;
            --text-main: #f8fafc;
            --text-sub: #94a3b8;
            --radius: 16px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Header & Status */
        header {
            width: 100%;
            max-width: 1000px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            margin-bottom: 40px;
        }

        h1 { font-size: 1.25rem; font-weight: 700; color: white; display: flex; align-items: center; gap: 10px; }
        
        .connection-status {
            padding: 6px 16px;
            border-radius: 50px;
            font-size: 0.85rem;
            font-weight: 600;
            background: #334155;
            color: #94a3b8;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .connection-status.connected { background: rgba(16, 185, 129, 0.2); color: var(--success); }
        .dot { width: 8px; height: 8px; background: currentColor; border-radius: 50%; }

        /* Main Layout */
        main {
            width: 100%;
            max-width: 1000px;
            padding: 0 20px;
            display: none; /* Hidden until connected */
            animation: fadeIn 0.5s ease;
        }

        .split-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
        }

        /* Mode Selector */
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            background: var(--surface);
            padding: 8px;
            border-radius: 12px;
            border: 1px solid var(--border);
            width: 100%;
            max-width: 500px;
        }

        .mode-btn {
            flex: 1;
            padding: 12px 20px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text-sub);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .mode-btn.active {
            background: var(--primary);
            color: white;
        }

        .mode-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-main);
        }

        .mode-section {
            display: none;
            width: 100%;
            animation: fadeIn 0.3s ease;
        }

        .mode-section.active {
            display: block;
        }

        @media (max-width: 768px) {
            .split-view { 
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .mode-selector {
                max-width: 100%;
                padding: 6px;
            }

            .mode-btn {
                padding: 10px 16px;
                font-size: 0.85rem;
            }

            .panel {
                padding: 20px;
                min-height: 300px;
            }

            .chat-container {
                height: 400px;
                max-height: 60vh;
            }

            .chat-header {
                padding: 15px;
            }

            .chat-messages {
                padding: 15px;
            }

            .message {
                max-width: 85%;
            }

            .chat-input-area {
                padding: 15px;
                flex-wrap: wrap;
            }

            .chat-input-wrapper {
                width: 100%;
            }

            .chat-actions {
                width: 100%;
                justify-content: space-between;
                margin-top: 10px;
                gap: 8px;
            }

            .chat-btn {
                flex: 1;
                padding: 10px 16px;
                font-size: 0.9rem;
                min-width: 0;
            }

            .chat-btn.secondary {
                flex: 0 0 auto;
                width: 44px;
                padding: 10px;
            }

            header {
                padding: 15px;
                flex-wrap: wrap;
                gap: 10px;
            }

            h1 {
                font-size: 1.1rem;
            }

            .connection-status {
                font-size: 0.75rem;
                padding: 5px 12px;
            }
        }

        @media (max-width: 480px) {
            main {
                padding: 0 15px;
            }

            .panel {
                padding: 15px;
            }

            .upload-area {
                padding: 20px 15px;
            }

            .upload-icon {
                font-size: 2.5rem;
            }

            .chat-container {
                height: 350px;
                border-radius: 12px;
            }

            .chat-header {
                padding: 12px;
                font-size: 0.9rem;
            }

            .chat-messages {
                padding: 12px;
                gap: 12px;
            }

            .message {
                max-width: 90%;
            }

            .message-content {
                padding: 10px 14px;
                font-size: 0.9rem;
            }

            .file-card {
                padding: 15px;
            }

            .mode-selector {
                margin-bottom: 20px;
            }

            .mode-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .chat-input {
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }

        /* Panels */
        .panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 30px;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        .panel-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title { font-size: 1.1rem; font-weight: 600; }
        .panel-icon { font-size: 1.5rem; }

        /* --- UPLOAD SECTION --- */
        .upload-area {
            flex: 1;
            border: 2px dashed var(--border);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            background: rgba(255,255,255,0.02);
            position: relative;
            cursor: pointer;
        }
        .upload-area:hover { border-color: var(--primary); background: rgba(59, 130, 246, 0.05); }
        
        .upload-icon { font-size: 3rem; margin-bottom: 15px; color: var(--text-sub); }
        .upload-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 15px;
        }
        .upload-btn:hover { background: var(--primary-hover); }

        #file-input { position: absolute; width: 100%; height: 100%; opacity: 0; cursor: pointer; top: 0; left: 0; }

        /* --- DOWNLOAD SECTION --- */
        .download-placeholder {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-sub);
            text-align: center;
        }
        .download-placeholder span { font-size: 3rem; margin-bottom: 10px; opacity: 0.3; }

        .file-card {
            background: #0f172a;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        #files-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 600px;
            overflow-y: auto;
            padding-right: 5px;
        }

        #files-list::-webkit-scrollbar {
            width: 8px;
        }

        #files-list::-webkit-scrollbar-track {
            background: var(--surface);
            border-radius: 4px;
        }

        #files-list::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        #files-list::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        .file-meta { margin-bottom: 15px; }
        .file-name { font-weight: 600; font-size: 1.1rem; margin-bottom: 5px; word-break: break-all; }
        .file-size { color: var(--text-sub); font-size: 0.9rem; }

        .download-btn {
            width: 100%;
            background: var(--success);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }
        .download-btn:disabled { background: #334155; cursor: not-allowed; }

        /* --- PROGRESS BARS --- */
        .progress-container {
            margin-top: 10px;
        }
        .progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-sub);
            margin-bottom: 5px;
        }
        .progress-track {
            width: 100%;
            height: 6px;
            background: #334155;
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.1s linear;
        }
        /* Green fill for receiving */
        .download-section .progress-fill { background: var(--success); }

        /* --- ONBOARDING (LINK) --- */
        #onboarding {
            text-align: center;
            max-width: 500px;
            margin-top: 100px;
            padding: 20px;
        }
        .link-display {
            background: #1e293b;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border);
            margin: 20px 0;
            font-family: monospace;
            word-break: break-all;
            color: var(--primary);
        }
        .action-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        }

        /* --- CHAT SECTION --- */
        .chat-section {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
        }

        .chat-container {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 500px;
            max-height: 70vh;
        }

        .chat-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: var(--surface);
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .message {
            display: flex;
            flex-direction: column;
            max-width: 70%;
            animation: slideIn 0.2s ease;
        }

        .message.own {
            align-self: flex-end;
            align-items: flex-end;
        }

        .message.other {
            align-self: flex-start;
            align-items: flex-start;
        }

        .message-header {
            font-size: 0.75rem;
            color: var(--text-sub);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .message-content {
            background: #0f172a;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 16px;
            word-wrap: break-word;
        }

        .message.own .message-content {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .message-image, .message-file {
            max-width: 100%;
            border-radius: 8px;
            margin-top: 5px;
            cursor: pointer;
        }

        .message-image {
            max-height: 300px;
            object-fit: contain;
        }

        .message-audio {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 8px;
            margin-top: 5px;
        }

        .audio-player {
            flex: 1;
            height: 32px;
        }

        .chat-input-area {
            padding: 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-radius: 12px;
            transition: all 0.2s;
        }

        .chat-input {
            background: #0f172a;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 16px;
            color: var(--text-main);
            font-family: inherit;
            font-size: 0.95rem;
            resize: none;
            min-height: 44px;
            max-height: 120px;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .chat-actions {
            display: flex;
            gap: 8px;
        }

        .chat-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .chat-btn:hover {
            background: var(--primary-hover);
        }

        .chat-btn.secondary {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-main);
        }

        .chat-btn.secondary:hover {
            background: #334155;
        }

        .chat-btn.recording {
            background: #ef4444;
            animation: pulse 1s infinite;
        }

        .file-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 8px;
            margin-top: 5px;
        }

        .file-preview-icon {
            font-size: 2rem;
        }

        .file-preview-info {
            flex: 1;
        }

        .file-preview-name {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .file-preview-size {
            font-size: 0.8rem;
            color: var(--text-sub);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <!-- Header -->
    <header>
        <h1>
            <span style="font-size:1.5rem">‚Üó</span> DropShare
        </h1>
        <div class="connection-status" id="status-badge">
            <div class="dot"></div>
            <span id="status-text">Disconnected</span>
        </div>
    </header>

    <!-- Onboarding Screen (Create/Join Link) -->
    <section id="onboarding">
        <h2 style="margin-bottom: 10px;">Secure P2P Connection</h2>
        <p style="color: var(--text-sub); margin-bottom: 20px;">
            Generate a secure link to share files directly with another device.
        </p>
        
        <div id="loader" style="font-size: 2rem; animation: spin 1s infinite linear;">‚Üª</div>

        <div id="host-controls" style="display: none;">
            <div class="link-display" id="share-link"></div>
            <button class="action-btn" id="share-btn" onclick="shareLink(event)">Share Link</button>
            <p style="margin-top: 20px; font-size: 0.9rem; color: var(--text-sub);">
                Share this link with the other person. Once they open it, you will be connected.
            </p>
        </div>
    </section>

    <!-- Main Transfer Interface -->
    <main id="transfer-ui">
        <!-- Mode Selector -->
        <div class="mode-selector" style="margin: 0 auto 30px;">
            <button class="mode-btn active" id="mode-file" data-mode="file">
                üìÅ File Exchange
            </button>
            <button class="mode-btn" id="mode-chat" data-mode="chat">
                üí¨ Chat
            </button>
        </div>

        <!-- File Exchange Mode -->
        <div class="mode-section active" id="file-mode">
            <div class="split-view">
            
            <!-- LEFT: UPLOAD -->
            <div class="panel upload-section">
                <div class="panel-header">
                    <span class="panel-title">Upload File</span>
                    <span class="panel-icon">‚¨Ü</span>
                </div>
                
                <div class="upload-area" id="drop-zone">
                    <input type="file" id="file-input">
                    <div class="upload-icon">üìÇ</div>
                    <h3>Click or Drag File Here</h3>
                    <p style="color: var(--text-sub); margin-top: 5px; font-size: 0.9rem;">Select a file to send to peer</p>
                    <button class="upload-btn">Browse Files</button>
                </div>

                <!-- Upload Progress (Hidden by default) -->
                <div class="progress-container" id="upload-progress" style="display: none; margin-top: 20px;">
                    <div class="file-card" style="padding: 15px;">
                        <div class="file-meta">
                            <div class="file-name" id="upload-filename">example.jpg</div>
                            <div class="file-size" id="upload-filesize">0 MB</div>
                        </div>
                        <div class="progress-labels">
                            <span id="upload-status">Sending...</span>
                            <span id="upload-percent">0%</span>
                        </div>
                        <div class="progress-track">
                            <div class="progress-fill" id="upload-bar"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- RIGHT: DOWNLOAD -->
            <div class="panel download-section">
                <div class="panel-header">
                    <span class="panel-title">Incoming Files</span>
                    <span class="panel-icon">‚¨á</span>
                </div>

                <div class="download-placeholder" id="empty-state">
                    <span>üì•</span>
                    <p>Waiting for files...</p>
                </div>

                <!-- Files List Container -->
                <div id="files-list" style="display: none; flex: 1; overflow-y: auto;">
                    <!-- Files will be dynamically added here -->
                </div>
            </div>
        </div>
        </div>

        <!-- Chat Mode -->
        <div class="mode-section" id="chat-mode">
            <div class="chat-section">
            <div class="chat-container">
                <div class="chat-header">
                    <span class="panel-title">üí¨ Live Chat</span>
                    <span id="chat-device-count" style="font-size: 0.85rem; color: var(--text-sub);">0 devices connected</span>
                </div>
                
                <div class="chat-messages" id="chat-messages">
                    <div style="text-align: center; color: var(--text-sub); padding: 20px;">
                        <p>Start chatting with connected devices...</p>
                    </div>
                </div>

                <div class="chat-input-area">
                    <div class="chat-input-wrapper" id="chat-drop-zone">
                        <input type="file" id="chat-file-input" style="display: none;" accept="image/*,audio/*,video/*">
                        <textarea 
                            id="chat-input" 
                            class="chat-input" 
                            placeholder="Type a message or drag files here..."
                            rows="1"
                        ></textarea>
                    </div>
                    <div class="chat-actions">
                        <button class="chat-btn secondary" id="attach-btn" title="Attach file">
                            üìé
                        </button>
                        <button class="chat-btn secondary" id="audio-btn" title="Record audio">
                            üé§
                        </button>
                        <button class="chat-btn" id="send-btn">
                            Send
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- Configuration ---
        const CHUNK_SIZE = 16 * 1024; // 16KB
        let peer;
        let connections = new Map(); // Map of connectionId -> {connection, deviceId, deviceFingerprint}
        let myId;
        let myDeviceFingerprint;
        let filesByConnection = new Map(); // Map of connectionId -> array of file objects
        let processedFileIds = new Set(); // Track files to prevent duplicates
        let forwardingFiles = new Map(); // Track files being forwarded: fileId -> Set of connectionIds that have received it

        // Generate device fingerprint
        function generateDeviceFingerprint() {
            // Use existing fingerprint from localStorage or generate new one
            let fingerprint = localStorage.getItem('deviceFingerprint');
            if (!fingerprint) {
                // Generate a unique fingerprint based on various device characteristics
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillText('Device fingerprint', 2, 2);
                const canvasFingerprint = canvas.toDataURL();
                
                const screenInfo = `${screen.width}x${screen.height}x${screen.colorDepth}`;
                const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const language = navigator.language;
                
                // Create a hash-like identifier
                const combined = `${canvasFingerprint}-${screenInfo}-${timezone}-${language}-${navigator.userAgent}`;
                fingerprint = btoa(combined).substring(0, 16).replace(/[^a-zA-Z0-9]/g, '');
                localStorage.setItem('deviceFingerprint', fingerprint);
            }
            return fingerprint;
        }

        myDeviceFingerprint = generateDeviceFingerprint();

        // --- Elements ---
        const onboarding = document.getElementById('onboarding');
        const transferUI = document.getElementById('transfer-ui');
        const statusBadge = document.getElementById('status-badge');
        const statusText = document.getElementById('status-text');

        // Mode switching
        const modeFileBtn = document.getElementById('mode-file');
        const modeChatBtn = document.getElementById('mode-chat');
        const fileModeSection = document.getElementById('file-mode');
        const chatModeSection = document.getElementById('chat-mode');
        let currentMode = 'file'; // Default to file mode

        // Mode switching handlers
        modeFileBtn.addEventListener('click', () => switchMode('file'));
        modeChatBtn.addEventListener('click', () => switchMode('chat'));

        function switchMode(mode) {
            if (currentMode === mode) return;
            
            currentMode = mode;
            
            // Update button states
            if (mode === 'file') {
                modeFileBtn.classList.add('active');
                modeChatBtn.classList.remove('active');
                fileModeSection.classList.add('active');
                chatModeSection.classList.remove('active');
            } else {
                modeChatBtn.classList.add('active');
                modeFileBtn.classList.remove('active');
                chatModeSection.classList.add('active');
                fileModeSection.classList.remove('active');
            }
        }

        // --- Init PeerJS ---
        const urlParams = new URLSearchParams(window.location.search);
        const remotePeerId = urlParams.get('id');

        peer = new Peer(null, { debug: 2 });

        peer.on('open', (id) => {
            myId = id;
            document.getElementById('loader').style.display = 'none';

            if (remotePeerId) {
                // JOINER
                statusText.textContent = "Connecting...";
                connectToHost(remotePeerId);
            } else {
                // HOST
                document.getElementById('host-controls').style.display = 'block';
                statusText.textContent = "Waiting for peer...";
                const shareUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}?id=${myId}`;
                document.getElementById('share-link').textContent = shareUrl;
            }
        });

        peer.on('connection', (c) => {
            // Host receiving connection - allow multiple connections
            setupConnection(c);
        });

        peer.on('error', (err) => {
            console.error(err);
            statusText.textContent = "Error";
            alert("Connection failed. Please try refreshing.");
        });

        function connectToHost(id) {
            const connection = peer.connect(id, { reliable: true });
            setupConnection(connection);
        }

        function setupConnection(connection) {
            const connId = connection.peer || connection.connectionId || `conn_${Date.now()}_${Math.random()}`;
            const deviceId = connection.peer || 'unknown';
            
            // Store connection with device info
            connections.set(connId, {
                connection: connection,
                deviceId: deviceId,
                deviceFingerprint: null // Will be set when we receive their fingerprint
            });
            filesByConnection.set(connId, []);

            // Send our device fingerprint when connection opens
            connection.on('open', () => {
                // Send our device info
                connection.send(JSON.stringify({
                    type: 'device-info',
                    deviceFingerprint: myDeviceFingerprint,
                    deviceId: myId
                }));

                onboarding.style.display = 'none';
                transferUI.style.display = 'block';
                statusBadge.classList.add('connected');
                const connectedCount = Array.from(connections.values()).filter(c => c.connection.open).length;
                statusText.textContent = `${connectedCount} Device${connectedCount > 1 ? 's' : ''} Connected`;
                updateChatDeviceCount();
            });

            connection.on('data', (data) => handleIncomingData(data, connId));
            connection.on('close', () => {
                // Remove all files from this connection
                removeFilesFromConnection(connId);
                connections.delete(connId);
                filesByConnection.delete(connId);
                
                const connectedCount = Array.from(connections.values()).filter(c => c.connection.open).length;
                if (connectedCount === 0) {
                    statusText.textContent = "Disconnected";
                    statusBadge.classList.remove('connected');
                } else {
                    statusText.textContent = `${connectedCount} Device${connectedCount > 1 ? 's' : ''} Connected`;
                }
                updateChatDeviceCount();
            });

            connection.on('error', (err) => {
                console.error('Connection error:', err);
                removeFilesFromConnection(connId);
                connections.delete(connId);
                filesByConnection.delete(connId);
            });
        }

        // --- UPLOAD LOGIC ---
        
        let currentFile = null;
        const fileInput = document.getElementById('file-input');

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            uploadFile(file);
        });

        function uploadFile(file) {
            // Get all open connections
            const openConnections = Array.from(connections.values()).filter(c => c.connection.open);
            if (openConnections.length === 0) {
                alert("No active connections. Please wait for a peer to connect.");
                return;
            }

            // Generate unique file ID to track this file
            const fileId = `file_${Date.now()}_${Math.random()}`;
            processedFileIds.add(fileId);

            // UI Update
            document.getElementById('drop-zone').style.display = 'none';
            document.getElementById('upload-progress').style.display = 'block';
            document.getElementById('upload-filename').textContent = file.name;
            document.getElementById('upload-filesize').textContent = formatBytes(file.size);

            // Send to all connected peers
            const totalConnections = openConnections.length;
            let completedCount = 0;
            const connectionProgress = new Map();

            // Initialize progress tracking for each connection
            openConnections.forEach((connInfo) => {
                connectionProgress.set(connInfo, 0);
            });

            // Send metadata to all connections with file ID and source device info
            openConnections.forEach((connInfo) => {
                if (connInfo.connection.open) {
                    connInfo.connection.send(JSON.stringify({
                        type: 'metadata',
                        fileId: fileId,
                        name: file.name,
                        size: file.size,
                        fileType: file.type,
                        sourceDeviceFingerprint: myDeviceFingerprint,
                        sourceDeviceId: myId
                    }));
                }
            });

            // Read file once and send chunks to all connections
            const reader = new FileReader();
            let offset = 0;

            reader.onload = (e) => {
                const chunk = e.target.result;
                
                // Send chunk to all open connections
                openConnections.forEach((connInfo) => {
                    if (connInfo.connection.open) {
                        try {
                            connInfo.connection.send(chunk);
                            const currentProgress = connectionProgress.get(connInfo) || 0;
                            connectionProgress.set(connInfo, currentProgress + chunk.byteLength);
                        } catch (err) {
                            console.error('Error sending chunk:', err);
                        }
                    }
                });

                offset += chunk.byteLength;
                
                // Update Progress UI
                const percent = Math.min(100, Math.floor((offset / file.size) * 100));
                document.getElementById('upload-bar').style.width = percent + '%';
                document.getElementById('upload-percent').textContent = percent + '%';

                if (offset < file.size) {
                    readSlice(offset);
                } else {
                    document.getElementById('upload-status').textContent = `Sent to ${totalConnections} device${totalConnections > 1 ? 's' : ''}!`;
                    setTimeout(resetUploadUI, 2000);
                }
            };

            const readSlice = (o) => {
                const slice = file.slice(o, o + CHUNK_SIZE);
                reader.readAsArrayBuffer(slice);
            };
            readSlice(0);
        }

        function resetUploadUI() {
            document.getElementById('drop-zone').style.display = 'flex';
            document.getElementById('upload-progress').style.display = 'none';
            document.getElementById('upload-bar').style.width = '0%';
            document.getElementById('upload-status').textContent = "Sending...";
            fileInput.value = '';
        }

        // --- DOWNLOAD LOGIC ---

        function handleIncomingData(data, connId) {
            const connInfo = connections.get(connId);
            if (!connInfo) return;

            let files = filesByConnection.get(connId) || [];
            let currentFile = files.find(f => f.status === 'receiving') || null;

            if (typeof data === 'string') {
                const parsed = JSON.parse(data);
                
                if (parsed.type === 'device-info') {
                    // Store device fingerprint for this connection
                    connInfo.deviceFingerprint = parsed.deviceFingerprint;
                    connInfo.deviceId = parsed.deviceId;
                    updateChatDeviceCount();
                    return;
                }

                if (parsed.type === 'chat-message') {
                    // Handle chat message
                    handleChatMessage(parsed, connInfo);
                    // Forward to other connections
                    forwardDataToOthers(data, connId, 'chat');
                    return;
                }

                if (parsed.type === 'chat-audio-start') {
                    // Start receiving audio stream
                    handleChatAudioStart(parsed, connInfo);
                    forwardDataToOthers(data, connId, 'chat');
                    return;
                }

                if (parsed.type === 'chat-audio-chunk') {
                    // Receive audio chunk
                    handleChatAudioChunk(parsed, connInfo);
                    forwardDataToOthers(data, connId, 'chat');
                    return;
                }

                if (parsed.type === 'chat-audio-end') {
                    // End audio stream
                    handleChatAudioEnd(parsed, connInfo);
                    forwardDataToOthers(data, connId, 'chat');
                    return;
                }

                if (parsed.type === 'chat-file') {
                    // Handle chat file (image or other file)
                    handleChatFile(parsed, connInfo);
                    forwardDataToOthers(data, connId, 'chat');
                    return;
                }
                
                if (parsed.type === 'metadata') {
                    const fileId = parsed.fileId || `file_${Date.now()}_${Math.random()}`;
                    
                    // Check if we've already processed this file (prevent duplicates)
                    if (processedFileIds.has(fileId)) {
                        // This file was already received from another connection, just forward
                        forwardDataToOthers(data, connId, fileId);
                        return;
                    }
                    
                    processedFileIds.add(fileId);
                    forwardingFiles.set(fileId, new Set([connId])); // Track that sender has this file
                    
                    // Get source device info
                    const sourceFingerprint = parsed.sourceDeviceFingerprint || connInfo.deviceFingerprint || connInfo.deviceId || 'Unknown';
                    const sourceDeviceId = parsed.sourceDeviceId || connInfo.deviceId || 'Unknown';
                    
                    // Create new file entry
                    currentFile = {
                        id: fileId,
                        connId: connId,
                        name: parsed.name,
                        size: parsed.size,
                        fileType: parsed.fileType,
                        receivedSize: 0,
                        buffer: [],
                        status: 'receiving',
                        element: null,
                        sourceDeviceFingerprint: sourceFingerprint,
                        sourceDeviceId: sourceDeviceId
                    };
                    files.push(currentFile);
                    filesByConnection.set(connId, files);
                    
                    // Create UI element for this file
                    createFileCard(currentFile);
                    
                    // Show files list
                    document.getElementById('empty-state').style.display = 'none';
                    document.getElementById('files-list').style.display = 'block';
                    
                    // Forward metadata to all other connections (broadcast)
                    forwardDataToOthers(data, connId, fileId);
                }
            } else if (currentFile) {
                // Binary Chunk
                currentFile.buffer.push(data);
                currentFile.receivedSize += data.byteLength;

                const percent = Math.min(100, Math.floor((currentFile.receivedSize / currentFile.size) * 100));
                updateFileProgress(currentFile, percent);

                if (currentFile.receivedSize === currentFile.size) {
                    finalizeDownload(currentFile);
                    // Clean up forwarding tracking when file is complete
                    forwardingFiles.delete(currentFile.id);
                }
                
                // Forward chunk to all other connections (broadcast)
                forwardDataToOthers(data, connId, currentFile.id);
            } else {
                // Received binary data but no current file - might be a forwarded chunk
                // Try to find the file in any connection
                let foundFile = null;
                for (const [cid, fileList] of filesByConnection.entries()) {
                    foundFile = fileList.find(f => f.status === 'receiving');
                    if (foundFile) break;
                }
                
                if (foundFile) {
                    // This is a forwarded chunk for an existing file
                    foundFile.buffer.push(data);
                    foundFile.receivedSize += data.byteLength;
                    const percent = Math.min(100, Math.floor((foundFile.receivedSize / foundFile.size) * 100));
                    updateFileProgress(foundFile, percent);
                    
                    if (foundFile.receivedSize === foundFile.size) {
                        finalizeDownload(foundFile);
                        forwardingFiles.delete(foundFile.id);
                    }
                    
                    // Forward to others
                    forwardDataToOthers(data, connId, foundFile.id);
                }
            }
        }

        function forwardDataToOthers(data, senderConnId, fileId) {
            // Forward data to all other connections except the sender
            // This creates a mesh network where all devices receive all files
            connections.forEach((connInfo, connId) => {
                if (connId !== senderConnId && connInfo.connection.open) {
                    try {
                        connInfo.connection.send(data);
                    } catch (err) {
                        console.error('Error forwarding data:', err);
                    }
                }
            });
        }

        function createFileCard(file) {
            const filesList = document.getElementById('files-list');
            const fileCard = document.createElement('div');
            fileCard.className = 'file-card';
            fileCard.id = `file-card-${file.id}`;
            
            // Get device fingerprint/identity
            const deviceFingerprint = file.sourceDeviceFingerprint || file.sourceDeviceId || 'Unknown';
            const displayFingerprint = deviceFingerprint.length > 12 ? deviceFingerprint.substring(0, 12) : deviceFingerprint;
            
            fileCard.innerHTML = `
                <div class="file-meta">
                    <div class="file-name">${escapeHtml(file.name)}</div>
                    <div class="file-size">${formatBytes(file.size)}</div>
                    <div style="font-size: 0.8rem; color: var(--text-sub); margin-top: 5px;">
                        From: <span style="font-family: monospace; color: var(--primary);">${displayFingerprint}</span>
                    </div>
                </div>
                
                <div class="progress-container" id="progress-${file.id}">
                    <div class="progress-labels">
                        <span id="status-${file.id}">Receiving...</span>
                        <span id="percent-${file.id}">0%</span>
                    </div>
                    <div class="progress-track">
                        <div class="progress-fill" id="bar-${file.id}"></div>
                    </div>
                </div>

                <a href="#" id="download-link-${file.id}" class="download-btn" style="display: none; margin-top: 15px;">
                    ‚¨á Download Now
                </a>
            `;
            
            filesList.appendChild(fileCard);
            file.element = fileCard;
        }

        function updateFileProgress(file, percent) {
            const bar = document.getElementById(`bar-${file.id}`);
            const percentEl = document.getElementById(`percent-${file.id}`);
            if (bar) bar.style.width = percent + '%';
            if (percentEl) percentEl.textContent = percent + '%';
        }

        function finalizeDownload(file) {
            const statusEl = document.getElementById(`status-${file.id}`);
            if (statusEl) statusEl.textContent = "Complete";
            
            const blob = new Blob(file.buffer, { type: file.fileType });
            const url = URL.createObjectURL(blob);
            
            const dlBtn = document.getElementById(`download-link-${file.id}`);
            if (dlBtn) {
                dlBtn.href = url;
                dlBtn.download = file.name;
                dlBtn.style.display = 'flex';
            }
            
            file.status = 'complete';
        }

        function removeFilesFromConnection(connId) {
            const files = filesByConnection.get(connId) || [];
            files.forEach(file => {
                if (file.element) {
                    file.element.remove();
                }
            });
            
            // Check if we should show empty state
            const allFiles = Array.from(filesByConnection.values()).flat();
            if (allFiles.length === 0) {
                document.getElementById('empty-state').style.display = 'flex';
                document.getElementById('files-list').style.display = 'none';
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // --- UTILS ---
        async function shareLink(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            const shareUrl = document.getElementById('share-link').textContent.trim();
            const btn = document.getElementById('share-btn');
            const originalText = btn.textContent;

            // Check if Web Share API is available
            if (navigator.share) {
                try {
                    await navigator.share({
                        title: 'DropShare - Secure P2P File Transfer',
                        text: 'Join me for a secure peer-to-peer file transfer',
                        url: shareUrl
                    });
                    btn.textContent = "Shared!";
                    setTimeout(() => btn.textContent = originalText, 2000);
                } catch (err) {
                    // User cancelled or error occurred, fallback to copy
                    if (err.name !== 'AbortError') {
                        console.error('Share failed:', err);
                        fallbackCopy(shareUrl, btn, originalText);
                    }
                }
            } else {
                // Fallback to clipboard copy if Web Share API is not available
                fallbackCopy(shareUrl, btn, originalText);
            }
            return false;
        }

        async function fallbackCopy(text, btn, originalText) {
            try {
                await navigator.clipboard.writeText(text);
                btn.textContent = "Copied!";
                setTimeout(() => btn.textContent = originalText, 2000);
            } catch (err) {
                console.error('Copy failed:', err);
                // Last resort: select text for manual copy
                const linkEl = document.getElementById('share-link');
                const range = document.createRange();
                range.selectNodeContents(linkEl);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
                btn.textContent = "Select & Copy";
                setTimeout(() => {
                    btn.textContent = originalText;
                    selection.removeAllRanges();
                }, 2000);
            }
        }

        function formatBytes(bytes, decimals = 2) {
            if (!+bytes) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
        }

        // Drag effects for file upload
        const dz = document.getElementById('drop-zone');
        ['dragenter', 'dragover'].forEach(e => dz.addEventListener(e, () => dz.style.borderColor = 'var(--primary)'));
        ['dragleave', 'drop'].forEach(e => dz.addEventListener(e, () => dz.style.borderColor = 'var(--border)'));

        // Drag effects for chat
        const chatDz = document.getElementById('chat-drop-zone');
        ['dragenter', 'dragover'].forEach(e => {
            chatDz.addEventListener(e, (ev) => {
                ev.preventDefault();
                chatDz.style.border = '2px dashed var(--primary)';
                chatDz.style.background = 'rgba(59, 130, 246, 0.05)';
            });
        });
        ['dragleave', 'drop'].forEach(e => {
            chatDz.addEventListener(e, (ev) => {
                ev.preventDefault();
                chatDz.style.border = 'none';
                chatDz.style.background = 'transparent';
            });
        });
        chatDz.addEventListener('drop', (e) => {
            e.preventDefault();
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                sendChatFile(files[0]);
            }
        });

        // --- CHAT FUNCTIONALITY ---

        let chatAudioRecorder = null;
        let chatAudioChunks = [];
        let receivingAudioStreams = new Map(); // Track audio streams being received
        let chatMessageId = 0;

        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const attachBtn = document.getElementById('attach-btn');
        const audioBtn = document.getElementById('audio-btn');
        const chatFileInput = document.getElementById('chat-file-input');

        // Auto-resize textarea
        chatInput.addEventListener('input', () => {
            chatInput.style.height = 'auto';
            chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
        });

        // Send text message
        sendBtn.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendChatMessage();
            }
        });

        // Attach file
        attachBtn.addEventListener('click', () => chatFileInput.click());
        chatFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) sendChatFile(file);
        });

        // Audio recording
        let isRecording = false;
        audioBtn.addEventListener('mousedown', startAudioRecording);
        audioBtn.addEventListener('mouseup', stopAudioRecording);
        audioBtn.addEventListener('mouseleave', stopAudioRecording);
        audioBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startAudioRecording();
        });
        audioBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopAudioRecording();
        });

        function updateChatDeviceCount() {
            const count = Array.from(connections.values()).filter(c => c.connection.open).length;
            document.getElementById('chat-device-count').textContent = `${count} device${count !== 1 ? 's' : ''} connected`;
        }

        function sendChatMessage() {
            const text = chatInput.value.trim();
            if (!text) return;

            const messageId = `msg_${Date.now()}_${chatMessageId++}`;
            const message = {
                type: 'chat-message',
                messageId: messageId,
                text: text,
                timestamp: Date.now(),
                senderFingerprint: myDeviceFingerprint,
                senderId: myId
            };

            // Display own message
            displayChatMessage(message, true);

            // Send to all connections
            const openConnections = Array.from(connections.values()).filter(c => c.connection.open);
            openConnections.forEach((connInfo) => {
                if (connInfo.connection.open) {
                    try {
                        connInfo.connection.send(JSON.stringify(message));
                    } catch (err) {
                        console.error('Error sending chat message:', err);
                    }
                }
            });

            chatInput.value = '';
            chatInput.style.height = 'auto';
        }

        function sendChatFile(file) {
            const messageId = `msg_${Date.now()}_${chatMessageId++}`;
            const reader = new FileReader();

            reader.onload = (e) => {
                const fileData = e.target.result;
                const isImage = file.type.startsWith('image/');
                const isAudio = file.type.startsWith('audio/');
                const isVideo = file.type.startsWith('video/');

                const message = {
                    type: 'chat-file',
                    messageId: messageId,
                    fileName: file.name,
                    fileType: file.type,
                    fileSize: file.size,
                    fileData: fileData, // Base64 encoded
                    isImage: isImage,
                    isAudio: isAudio,
                    isVideo: isVideo,
                    timestamp: Date.now(),
                    senderFingerprint: myDeviceFingerprint,
                    senderId: myId
                };

                // Display own file
                displayChatFile(message, true);

                // Send to all connections
                const openConnections = Array.from(connections.values()).filter(c => c.connection.open);
                openConnections.forEach((connInfo) => {
                    if (connInfo.connection.open) {
                        try {
                            connInfo.connection.send(JSON.stringify(message));
                        } catch (err) {
                            console.error('Error sending chat file:', err);
                        }
                    }
                });
            };

            reader.readAsDataURL(file);
            chatFileInput.value = '';
        }

        async function startAudioRecording() {
            if (isRecording) return;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Try to use Opus codec if available
                const options = {
                    mimeType: 'audio/webm;codecs=opus'
                };
                
                // Check if Opus is supported, fallback to default
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'audio/webm'; // Fallback
                }

                chatAudioRecorder = new MediaRecorder(stream, options);
                chatAudioChunks = [];
                isRecording = true;

                audioBtn.classList.add('recording');
                audioBtn.textContent = 'üî¥ Recording...';

                chatAudioRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chatAudioChunks.push(e.data);
                    }
                };

                chatAudioRecorder.onstop = () => {
                    stream.getTracks().forEach(track => track.stop());
                    sendAudioMessage();
                };

                chatAudioRecorder.start(100); // Collect data every 100ms for streaming
            } catch (err) {
                console.error('Error starting audio recording:', err);
                alert('Could not access microphone. Please check permissions.');
                isRecording = false;
            }
        }

        function stopAudioRecording() {
            if (!isRecording || !chatAudioRecorder) return;
            
            isRecording = false;
            audioBtn.classList.remove('recording');
            audioBtn.textContent = 'üé§';

            if (chatAudioRecorder.state !== 'inactive') {
                chatAudioRecorder.stop();
            }
        }

        function sendAudioMessage() {
            if (chatAudioChunks.length === 0) return;

            const messageId = `audio_${Date.now()}_${chatMessageId++}`;
            const blob = new Blob(chatAudioChunks, { type: chatAudioRecorder.mimeType || 'audio/webm' });

            // Convert to base64 for transmission
            const reader = new FileReader();
            reader.onload = () => {
                const audioData = reader.result;

                const message = {
                    type: 'chat-audio-start',
                    messageId: messageId,
                    audioData: audioData,
                    mimeType: chatAudioRecorder.mimeType || 'audio/webm',
                    timestamp: Date.now(),
                    senderFingerprint: myDeviceFingerprint,
                    senderId: myId
                };

                // Display own audio message
                displayChatAudio(message, true);

                // Send to all connections
                const openConnections = Array.from(connections.values()).filter(c => c.connection.open);
                openConnections.forEach((connInfo) => {
                    if (connInfo.connection.open) {
                        try {
                            connInfo.connection.send(JSON.stringify(message));
                        } catch (err) {
                            console.error('Error sending audio message:', err);
                        }
                    }
                });
            };

            reader.readAsDataURL(blob);
            chatAudioChunks = [];
        }

        function handleChatMessage(parsed, connInfo) {
            displayChatMessage(parsed, false);
        }

        function handleChatFile(parsed, connInfo) {
            displayChatFile(parsed, false);
        }

        function handleChatAudioStart(parsed, connInfo) {
            displayChatAudio(parsed, false);
        }

        function handleChatAudioChunk(parsed, connInfo) {
            // Handle streaming audio chunks if needed
        }

        function handleChatAudioEnd(parsed, connInfo) {
            // Handle audio stream end
        }

        function displayChatMessage(message, isOwn) {
            // Remove placeholder if exists
            const placeholder = chatMessages.querySelector('div[style*="text-align: center"]');
            if (placeholder) placeholder.remove();

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isOwn ? 'own' : 'other'}`;
            messageDiv.dataset.messageId = message.messageId;

            const senderName = isOwn ? 'You' : (message.senderFingerprint || 'Unknown').substring(0, 8);
            const time = new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            messageDiv.innerHTML = `
                <div class="message-header">
                    <span>${escapeHtml(senderName)}</span>
                    <span>${time}</span>
                </div>
                <div class="message-content">
                    ${escapeHtml(message.text).replace(/\n/g, '<br>')}
                </div>
            `;

            chatMessages.appendChild(messageDiv);
            scrollChatToBottom();
        }

        function displayChatFile(message, isOwn) {
            const placeholder = chatMessages.querySelector('div[style*="text-align: center"]');
            if (placeholder) placeholder.remove();

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isOwn ? 'own' : 'other'}`;
            messageDiv.dataset.messageId = message.messageId;

            const senderName = isOwn ? 'You' : (message.senderFingerprint || 'Unknown').substring(0, 8);
            const time = new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            let content = '';
            if (message.isImage) {
                content = `<img src="${message.fileData}" alt="${escapeHtml(message.fileName)}" class="message-image" onclick="window.open(this.src, '_blank')">`;
            } else if (message.isVideo) {
                content = `<video src="${message.fileData}" controls class="message-image" style="max-width: 100%; max-height: 300px;"></video>`;
            } else {
                content = `
                    <div class="file-preview">
                        <div class="file-preview-icon">üìÑ</div>
                        <div class="file-preview-info">
                            <div class="file-preview-name">${escapeHtml(message.fileName)}</div>
                            <div class="file-preview-size">${formatBytes(message.fileSize)}</div>
                        </div>
                        <a href="${message.fileData}" download="${message.fileName}" class="chat-btn" style="padding: 8px 12px; font-size: 0.85rem;">‚¨á</a>
                    </div>
                `;
            }

            messageDiv.innerHTML = `
                <div class="message-header">
                    <span>${escapeHtml(senderName)}</span>
                    <span>${time}</span>
                </div>
                <div class="message-content">
                    ${content}
                </div>
            `;

            chatMessages.appendChild(messageDiv);
            scrollChatToBottom();
        }

        function displayChatAudio(message, isOwn) {
            const placeholder = chatMessages.querySelector('div[style*="text-align: center"]');
            if (placeholder) placeholder.remove();

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isOwn ? 'own' : 'other'}`;
            messageDiv.dataset.messageId = message.messageId;

            const senderName = isOwn ? 'You' : (message.senderFingerprint || 'Unknown').substring(0, 8);
            const time = new Date(message.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const audioId = `audio_${message.messageId}`;
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span>${escapeHtml(senderName)}</span>
                    <span>${time}</span>
                </div>
                <div class="message-content">
                    <div class="message-audio">
                        <audio id="${audioId}" controls class="audio-player">
                            <source src="${message.audioData}" type="${message.mimeType}">
                            Your browser does not support audio playback.
                        </audio>
                    </div>
                </div>
            `;

            chatMessages.appendChild(messageDiv);
            
            // Auto-play if it's from others (optional - you can remove this)
            const audio = document.getElementById(audioId);
            if (audio && !isOwn) {
                // Don't auto-play, let user control
            }
            
            scrollChatToBottom();
        }

        function scrollChatToBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

    </script>
</body>
</html>